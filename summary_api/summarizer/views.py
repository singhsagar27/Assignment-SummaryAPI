import os
import time
import logging
from dotenv import load_dotenv
from groq import Groq
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.authentication import JWTAuthentication

from .models import Summary
from .serializers import SummarySerializer

# Load environment variables
load_dotenv()

# Initialize Groq client
client = Groq(api_key=os.getenv("GROQ_API_KEY"))

# Load model name from environment variable
GROQ_MODEL = os.getenv("GROQ_MODEL", "llama-3.3-70b-versatile")  # Default model

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def generate_llm_response(prompt: str, text: str, max_retries=3) -> str:
    """
    Sends a request to the Groq API to generate a response with automatic retry on rate limits.

    Args:
        prompt (str): The system's instruction for the LLM.
        text (str): The user's input text.
        max_retries (int): Number of retries in case of API failures (default: 3).

    Returns:
        str: The response generated by the LLM.

    Raises:
        ValueError: If the response is empty.
        Exception: If API errors persist.
    """
    retries = 0
    while retries < max_retries:
        try:
            logger.info(f"Attempt {retries + 1}: Sending request to Groq API")
            chat_completion = client.chat.completions.create(
                messages=[
                    {"role": "system", "content": prompt},
                    {"role": "user", "content": text},
                ],
                model=GROQ_MODEL,
            )

            response_content = chat_completion.choices[0].message.content.strip()

            if not response_content:
                logger.warning("Received empty response from LLM.")
                raise ValueError("Received empty response from LLM.")

            logger.info("Received valid response from Groq API.")
            return response_content

        except Exception as e:
            logger.error(f"Error during LLM request: {e}")
            if "429" in str(e):  # Rate limit detected
                wait_time = 2 ** retries  # Exponential backoff
                logger.warning(f"Rate limited. Retrying in {wait_time} seconds...")
                time.sleep(wait_time)
                retries += 1
            else:
                raise Exception(f"LLM API error: {str(e)}")

    raise Exception("Max retries reached. LLM API is not responding.")

# Create a reusable base view
class BaseLLMView(APIView):
    """
    A base view for LLM API endpoints that handles common logic.
    """
    authentication_classes = [JWTAuthentication]
    permission_classes = [IsAuthenticated]
    def process_request(self, request, prompt, field_name):
        """
        Extracts input text from request, validates it, and calls LLM.
        """
        text = request.data.get("text", "").strip()
        if not text:
            return Response({"error": "Text is required"}, status=400)

        try:
            result = generate_llm_response(prompt, text)

            # Save to the database
            summary_instance = Summary.objects.create(
                original_text=text,
                **{field_name: result}  # Dynamically store either summary or bullet points
            )

            return Response(SummarySerializer(summary_instance).data)

        except ValueError as ve:
            return Response({"error": str(ve)}, status=400)
        except Exception as e:
            return Response({"error": str(e)}, status=500)

class GenerateSummaryView(BaseLLMView):
    """
    API endpoint to generate a summary from the given text using the Groq LLM.
    """

    def post(self, request):
        return self.process_request(request, "Summarize this text.", "summary")

class GenerateBulletPointsView(BaseLLMView):
    """
    API endpoint to generate bullet points from the given text using the Groq LLM.
    """

    def post(self, request):
        return self.process_request(request, "Convert this text into bullet points.", "bullet_points")
